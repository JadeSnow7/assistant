
# 部署与运维配置

<cite>
**本文档引用的文件**   
- [build.sh](file://scripts/build.sh)
- [run_server.sh](file://scripts/run_server.sh)
- [CMakeLists.txt](file://CMakeLists.txt)
- [cpp/CMakeLists.txt](file://cpp/CMakeLists.txt)
- [python/main.py](file://python/main.py)
- [python/agent/orchestrator.py](file://python/agent/orchestrator.py)
- [python/models/schemas.py](file://python/models/schemas.py)
- [python/agent/api_router.py](file://python/agent/api_router.py)
</cite>

## 目录
1. [编译与构建流程](#编译与构建流程)  
2. [服务启动与参数调优](#服务启动与参数调优)  
3. [环境变量控制系统行为](#环境变量控制系统行为)  
4. [容器化部署建议](#容器化部署建议)  
5. [健康检查接口集成](#健康检查接口集成)  
6. [日志收集方案](#日志收集方案)  
7. [性能压测与资源预估](#性能压测与资源预估)

## 编译与构建流程

本项目采用 `CMake` 作为 C++ 模块的构建系统，通过 `build.sh` 脚本统一管理整个项目的编译、依赖安装和测试流程。

### C++模块编译选项配置

在 `CMakeLists.txt` 文件中定义了核心编译参数：

- **C++标准**: 使用 C++20 标准（`set(CMAKE_CXX_STANDARD 20)`），确保支持现代语言特性。
- **编译模式**: 
  - Release 模式启用 `-O3` 优化并定义 `NDEBUG` 宏以关闭调试断言。
  - Debug 模式包含调试信息 `-g` 并禁用优化 `-O0`。
- **依赖查找**: 通过 `find_package(Protobuf REQUIRED)` 和 `find_package(gRPC REQUIRED)` 自动定位 Protobuf 和 gRPC 库，确保协议序列化和远程调用功能正常工作。
- **链接方式**: 在 `cpp/CMakeLists.txt` 中使用 `target_link_libraries` 显式链接 `gRPC::grpc++` 和 `protobuf::libprotobuf`，保证符号正确解析。

目前构建脚本未显式启用 GPU 加速。若需添加 GPU 支持（如 CUDA 或 OpenCL），可在 `CMakeLists.txt` 中增加如下配置：
```cmake
find_package(CUDA REQUIRED)
set(CMAKE_CUDA_STANDARD 14)
target_sources(ai_assistant_core PRIVATE src/gpu_engine.cu)
target_link_libraries(ai_assistant_core ${CUDA_LIBRARIES})
```

### 构建脚本执行流程

`scripts/build.sh` 提供了完整的构建流水线：

1. **依赖检查**: 验证 `cmake`, `python3`, `pip3` 是否已安装。
2. **目录设置**: 创建 `build/` 目录用于存放中间产物，实现源码隔离。
3. **C++编译**: 执行 `cmake ..` 配置项目，并调用 `make -j$(nproc)` 多线程编译，最后运行 `make install` 将产出物复制到 `install/` 目录。
4. **Python依赖安装**: 使用 `pip3 install -r requirements.txt` 安装 Python 第三方库。可选参数 `--venv` 可创建独立虚拟环境避免依赖冲突。
5. **自动化测试**: 若未指定 `--skip-tests`，则自动运行 C++ 单元测试（`./tests/test_runner`）和 Python 测试（`pytest tests/`）。

该脚本支持以下命令行参数：
- `--skip-tests`: 跳过测试阶段，加快构建速度。
- `--venv`: 启用 Python 虚拟环境。
- `--help`: 查看帮助信息。

**Section sources**
- [build.sh](file://scripts/build.sh#L0-L158)
- [CMakeLists.txt](file://CMakeLists.txt#L0-L28)
- [cpp/CMakeLists.txt](file://cpp/CMakeLists.txt#L0-L36)

## 服务启动与参数调优

服务由 `run_server.sh` 脚本启动，采用分层架构：C++ 后端提供高性能计算能力，Python 前端暴露 REST API 接口。

### 启动流程分析

1. **目录初始化**: 自动创建 `logs/`, `data/`, `python/plugins/` 等必要目录。
2. **端口检测**: 使用 `lsof` 检查 gRPC（默认 50051）和 HTTP（默认 8000）端口是否被占用，若存在冲突则提示用户选择终止现有进程或退出。
3. **C++后端启动**: 以前台守护进程方式运行 `ai_assistant_server`，输出重定向至 `logs/grpc_server.log`。启动后等待 3 秒并通过 PID 检查确认进程存活。
4. **Python前端启动**: 进入 `python/` 目录，设置环境变量后调用 `uvicorn` 启动 FastAPI 服务。

### 启动参数调优

`run_server.sh` 支持以下关键参数进行性能调优：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `--host` | 0.0.0.0 | 绑定的网络接口地址 |
| `--port` | 8000 | HTTP API 服务端口 |
| `--grpc-port` | 50051 | gRPC 内部通信端口 |
| `--debug` | false | 是否启用调试模式（开启热重载） |
| `--log-level` | INFO | 日志输出级别（DEBUG/INFO/WARNING/ERROR） |

在生产环境中，Python API 服务使用 `--workers 4` 启动多个工作进程，充分利用多核 CPU。此数值可根据服务器核心数适当调整，一般建议设置为 CPU 核心数或其 2 倍。

此外，可通过环境变量进一步控制行为：
- `GRPC_SERVER_ADDRESS`: 指定 C++ 服务地址，便于微服务部署场景。
- `DEBUG`: 控制是否启用开发模式。
- `LOG_LEVEL`: 动态调整日志详细程度。

**Section sources**
- [run_server.sh](file://scripts/run_server.sh#L0-L272)
- [python/main.py](file://python/main.py#L52-L116)

## 环境变量控制系统行为

系统通过环境变量实现灵活的行为控制，无需修改代码即可适应不同部署环境。

### 模型优先级切换

虽然当前代码中未直接体现本地/云端模型优先级的环境变量控制，但在 `AgentOrchestrator` 类中存在决策策略字段 `decision_strategy`，其类型为 `DecisionStrategy` 枚举，包含 `LOCAL_FIRST`, `CLOUD_FIRST`, `SMART_ROUTE` 等选项。

可通过扩展 `run_server.sh` 脚本，在启动时读取环境变量 `MODEL_ROUTING_STRATEGY` 并传递给 Python 服务来实现动态切换：

```bash
export MODEL_ROUTING_STRATEGY=${MODEL_ROUTING_STRATEGY:-"smart_route"}
```

然后在 `main.py` 的 `lifespan` 函数中注入该配置，使调度器根据策略选择模型执行路径。

### 日志级别调整

日志级别由 `LOG_LEVEL` 环境变量控制，影响 C++ 和 Python 两部分：

- **C++侧**: 通过 `--log-level=$LOG_LEVEL` 传递给 `ai_assistant_server`，内部使用标准日志库输出。
- **Python侧**: 通过 `--log-level $(echo $LOG_LEVEL | tr '[:upper:]' '[:lower:]')` 转换为小写后传给 `uvicorn`，兼容其日志系统。

支持的日志级别包括：`DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`。生产环境推荐使用 `INFO` 或更高层级以减少 I/O 开销。

**Section sources**
- [run_server.sh](file://scripts/run_server.sh#L73-L130)
- [python/agent/orchestrator.py](file://python/agent/orchestrator.py#L30-L70)
- [python/main.py](file://python/main.py#L0-L49)

## 容器化部署建议

### Dockerfile 建议

基于当前构建逻辑，推荐的 `Dockerfile` 如下：

```dockerfile
FROM ubuntu:22.04

# 安装依赖
RUN apt-get update && apt-get install -y \
    cmake g++ python3 pip wget curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# 复制源码
COPY . .

# 构建C++模块
RUN mkdir build && cd build \
    && cmake .. -DCMAKE_BUILD_TYPE=Release \
    && make -j$(nproc) && make install

# 安装Python依赖
RUN pip3 install -r requirements.txt

# 暴露端口
EXPOSE 8000 50051

# 启动服务
CMD ["./scripts/run_server.sh"]
```

构建镜像：
```bash
docker build -t ai-assistant .
```

运行容器：
```bash
docker run -d -p 8000:8000 -p 50051:50051 \
  -e LOG_LEVEL=INFO \
  --name assistant-container ai-assistant
```

### Kubernetes 集成思路

建议将 C++ 和 Python 服务拆分为两个独立的 Deployment，通过 Service 实现内部通信：

1. **gRPC服务部署**:
   - 使用 `DaemonSet` 或 `Deployment` 部署 C++ 模块。
   - 通过 Headless Service 提供稳定 DNS 记录。
   - 可结合 Node Affinity 调度到具备 GPU 的节点。

2. **API网关部署**:
   - 使用 `Deployment` 部署 Python 服务，副本数根据负载弹性伸缩。
   - 配置 `GRPC_SERVER_ADDRESS` 指向 gRPC 服务的 ClusterIP。
   - 使用 Ingress 对外暴露 HTTPS 接口。

3. **配置管理**:
   - 使用 ConfigMap 存储 `settings` 配置。
   - 使用 Secret 管理敏感信息（如插件 API Key）。
   - 利用 Downward API 注入 Pod 元数据。

4. **监控与自愈**:
   - 配置 Liveness/Readiness 探针对接 `/health` 接口。
   - 结合 Prometheus 抓取指标，实现自动告警与扩缩容。

**Section sources**
- [run_server.sh](file://scripts/run_server.sh#L132-L196)
- [python/main.py](file://python/main.py#L52-L116)

## 健康检查接口集成

系统已内置多层次健康检查机制，保障服务稳定性。

### 健康检查接口

- **HTTP健康检查**: `GET /health` 返回 JSON 格式的组件状态，包括 `grpc_client` 和 `orchestrator` 的连通性。
- **系统状态接口**: `GET /system/status` 提供详细的资源使用情况，如 CPU、内存、GPU 使用率及各组件健康状态。

这些接口由 `python/main.py` 和 `api_router.py` 实现，利用 FastAPI 的依赖注入机制获取运行时实例并执行探测。

### 脚本级健康检查

`run_server.sh` 中的 `health_check()` 函数在服务启动后自动执行：
1. 使用 `nc -z` 检查 gRPC 端口是否监听。
2. 使用 `curl` 请求 `/health` 端点验证 HTTP 服务可用性。

只有两项检查均通过才会